/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package jdk.jigsaw.module.internal;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.StringJoiner;

/**
 * Supporting class for computing, encoding and decoding hashes (message
 * digests).
 */

public class Hasher {
    private Hasher() { }

    /**
     * A supplier of an encoded message digest.
     */
    public static interface HashSupplier {
        String generate(String algorithm);
    }

    /**
     * Encapsulates the result of hashing the contents of a number of module
     * artifacts. The {@link #toString} and {@link #decode} methods can be used
     * to persist and reconstitute an instance of this type.
     */
    public static class DependencyHashes {
        private final String algorithm;
        private final Map<String, String> nameToHash;

        private DependencyHashes(String algorithm, Map<String, String> nameToHash) {
            this.algorithm = algorithm;
            this.nameToHash = nameToHash;
        }

        public String algorithm() {
            return algorithm;
        }

        public String get(String dn) {
            return nameToHash.get(dn);
        }

        /**
         * Returns a String that encodes the algorithm and the hash of each
         * dependence.
         */
        public String toString() {
            StringJoiner joiner = new StringJoiner(",");
            for (Map.Entry<String, String> entry: nameToHash.entrySet()) {
                joiner.add(entry.getKey() + "@" + entry.getValue());
            }
            return algorithm + ":" + joiner.toString();
        }

        /**
         * Decodes a String generated by the {@link #toString}.
         *
         * @throws IllegalArgumentException if the String cannot be decoded
         */
        public static DependencyHashes decode(String s) {
            if (s == null)
                return null;

            // SHA-256:<hashes>
            String[] parts = s.split("\\:");
            if (parts.length != 2)
                throw new IllegalArgumentException("Cannot parse " + s);

            // name/hash[,name/hash]*
            String algorithm = parts[0];
            String hashes = parts[1];
            Map<String, String> nameToHash = new HashMap<>();
            for (String element: hashes.split(",")) {
                int i = element.indexOf('@');
                if (i > 0) {
                    String name = element.substring(0, i);
                    String hash = element.substring(i+1, element.length());
                    nameToHash.put(name, hash);
                }
            }

            return new DependencyHashes(algorithm, nameToHash);
        }
    }


    /**
     * Computes the hash for the given file with the given message digest
     * algorithm. Returns the results a base64-encoded String.
     *
     * @throws UncheckedIOException if an I/O error occurs
     * @throws RuntimeException if the algorithm is not available
     */
    public static String generate(Path file, String algorithm) {
        try {
            MessageDigest md = MessageDigest.getInstance(algorithm);
            md.update(Files.readAllBytes(file));
            byte[] bytes = md.digest();
            return Base64.getEncoder().encodeToString(bytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (IOException ioe) {
            throw new UncheckedIOException(ioe);
        }
    }

    /**
     * Computes the hash for every entry in the given map, returning a
     * {@code DependencyHashes} to encapsulate the result. The map key is
     * the entry name, typically the module name. The map value is the file
     * path to the entry (module artifact).
     */
    public static DependencyHashes generate(Map<String, Path> map, String algorithm) {
        Map<String, String> nameToHash = new HashMap<>();
        for (Map.Entry<String, Path> entry: map.entrySet()) {
            String name = entry.getKey();
            Path path = entry.getValue();
            nameToHash.put(name, generate(path, algorithm));
        }
        return new DependencyHashes(algorithm, nameToHash);
    }
}
